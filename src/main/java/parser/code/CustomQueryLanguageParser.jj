options {
  OTHER_AMBIGUITY_CHECK = 1;
  STATIC = true;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = false;
  IGNORE_CASE = false;
  USER_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = false;
  BUILD_PARSER = true;
  BUILD_TOKEN_MANAGER = true;
  SANITY_CHECK = true;
}

PARSER_BEGIN(CQLParser)
package parser.generated;

import java.util.*;
import parser.helper.*;
import parser.querybuilder.*;
import javax.persistence.criteria.Expression ;import javax.persistence.criteria.Predicate;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
/**
 * Simple brace matcher.
 */
public class CQLParser {

  /** Main entry point.
  public static void main(String args[]) throws ParseException {
    CQLParser parser = new CQLParser(System.in);

    Expr expr = parser.FilterLogicOr();

    System.out.println();
  }*/

    private final Logger logger = LoggerFactory.getLogger(ResourceManager.class);
}

PARSER_END(CQLParser)

TOKEN : {
    /* Blocks */
    <t_order: "order"> |
    <t_filter: "filter"> |
    <t_group: "groups"> |
    <t_result: "results"> |
    /* Arithmetic */
    <plus: "+"> |
    <minus: "-"> |
    <prod: "*"> |
    <quot: "/"> |
    <numberize: "num"> |
    /* Logic */
    <and: "and"> |
    <or: "or"> |
    <lpar: "("> |
    <rpar: ")"> |
    /* Aggregats */
    <aggregate: "sum" | "avg" | "min" | "max" | "count" > |
    /* Ordering */
    <ascending: "ascending"> |
    <descending: "descending"> |
    /* Groups */
    <with: "with"> |
    /* comparison operators */
    <equal: "="> |
    <greater: ">"> |
    <greater_eq: ">="> |
    <smaller_eq: "<="> |
    <smaller: "<"> |
    <between: "between"> /* this is not a binary operator */ |
    <like: "like"> |
    <startwith: "startswith"> |
    <endswith: "endswith"> |
    <contain: "contains"> |
    <in: "in"> /* requires list specification TODO: implement lists */ |
    <hasflag:"hasflag"> /* requires flag implementation TODO: implement flags */ |
    /* data-types */
    <quote: "\""> : STRING_STATE |
    <integer: "0" | (("-")? ["1"-"9"] (["0"-"9"])*)> |
    <floatingpoint: ("-")?((["1"-"9"](["0"-"9"])*)|("0"))"."["0"-"9"](["0"-"9"])*(("e"("-")?["1"-"9"](["0"-"9"])*)?)?> |
    <bool: "true" | "false"> |
    <datetime: (["0"-"9"]){2}"."(["0"-"9"]){2}"."(["0"-"9"]){4}(" "((["0"-"9"]){2}":"(["0"-"9"]){2}))?> /* dd.mm.yyyy HH:MM */ |
    /* fieldnames */
    <fieldname: ["a"-"z","A"-"Z"](["0"-"9","a"-"z","A"-"Z"])+>
}

<STRING_STATE> TOKEN : {
    <endquote: <quote>> : DEFAULT
   |<CHAR: ~["\"", "\\"]>
}

<STRING_STATE> MORE : {
    "\\" : ESC_STATE
}

<ESC_STATE> TOKEN : {
    <cntrl_esc: ["\"", "\\", "/", "b", "f", "n", "r", "t"]> : STRING_STATE
}

SKIP : {
    " " | "\t" | "\n"
}

/** TODO: Use generics (refactor to new JavaCC version...) */

void Filter(FilterSelector selector) : {
    Predicate predicate;
}{
    (<t_filter> predicate=SelectorLogicOr(selector) {selector.setFilterPredicate(predicate);})?
}

Predicate SelectorLogicOr(LogicSelector selector):
{
    Predicate predicate1;
    Predicate predicate2;
    List<Predicate> predicates = new LinkedList<Predicate>();
}
{
    predicate1=SelectorLogicAnd(selector) (<or> predicate2=SelectorLogicAnd(selector) { predicates.add(predicate2); } )*
    {
        predicates.add(predicate1);
        return selector.handlePredicateList(predicates, LogicOperator.Or);
    }
}

Predicate SelectorLogicAnd(LogicSelector selector):
{
    Predicate predicate1;
    Predicate predicate2;
    List<Predicate> predicates = new LinkedList<Predicate>();
}
{
    predicate1=SelectorBoolExpression(selector) (<and> predicate2=SelectorBoolExpression(selector) { predicates.add(predicate2); })*
    {
        predicates.add(predicate1);
        return selector.handlePredicateList(predicates, LogicOperator.And);
    }
}

Predicate SelectorBoolExpression(LogicSelector selector): {
    Token t;
    Predicate predicate;

}
{
    <lpar> predicate=SelectorLogicOr(selector) <rpar>
    {
        return predicate;
    } |
    // check the fieldname for boolean type
    LOOKAHEAD({selector.getResourceManager().isFieldOfType(getToken(1).image, Boolean.class)}) predicate=BoolField(selector) {
        return predicate;
    } |
    predicate=CompExpression(selector)
    {
       return predicate;
    }
    // Check if this particular token is a boolean field


}

// TODO: implement
Predicate BoolField(LogicSelector selector):
{
    Predicate predicate;
    Token t;
}{
      t=<fieldname> {
            return selector.handleBoolean(selector.getResourceManager().getReferencedFieldAsType(t.image, Boolean.class));
      }
}

Predicate CompExpression(LogicSelector selector): {
    Token cop;
    Expression<Number> expression1;
    Expression<Number> expression2;
    Expression<Number> expression3;
}
{
    // Numeric stuff
    expression1=NumericSum(selector.getArithmeticSelector())
    ((cop=NumCompOperator()
    expression2=NumericSum(selector.getArithmeticSelector())
    {
        return Utils.processNumericComparison(expression1, cop.image, expression2, selector);
    })

    | (cop=<between> expression2=NumericSum(selector.getArithmeticSelector()) <and> expression3=NumericSum(selector.getArithmeticSelector())
    {
        return Utils.processTernaryComparison(expression1, cop.image, expression2, expression3, selector);
    }))
    // String stuff (still missing)

}

Token NumCompOperator(): {
    Token cop;
}
{
    (cop=<equal> | cop=<greater> | cop=<smaller> | cop=<greater_eq> | cop=<smaller_eq> ) {
        return cop;
    }
}

Token StringCompOperator(): {
    Token cop;
}
{
    (cop=<like> | cop=<startwith> | cop=<endswith> | cop=<contain>) {
        return cop;
    }
}



Expression<Number> NumericSum(ArithmeticSelector selector): {
    Expression<Number> expression1;
    Expression<Number> expression2;
    Token t;
    List<ArithmeticSumExpression> sumExpressionList = new LinkedList<ArithmeticSumExpression>();
} {
    expression1=NumericProd(selector) ((t=<plus> | t=<minus>) expression2=NumericProd(selector) {
        sumExpressionList.add(new ArithmeticSumExpression(expression2, t.image));
    })*
    {
        return selector.sum(expression1, sumExpressionList);
    }
}

Expression<Number> NumericProd(ArithmeticSelector selector): {
    Expression<Number> expression1;
    Expression<Number> expression2;
    Token t;
    List<ArithmeticProdExpression> prodExpressionList = new LinkedList<ArithmeticProdExpression>();
}{
    expression1=NumericBase(selector) ((t=<prod> | t=<quot>) expression2=NumericBase(selector) {
        prodExpressionList.add(new ArithmeticProdExpression(expression2, t.image));
    })*
    {
        return selector.prod(expression1, prodExpressionList);
    }
}

/**
* TODO: Position the aggregates differently this makes no sense as it is!
*/
Expression<Number> NumericBase(ArithmeticSelector selector): {
    Number value;
    Expression<Number> expression;
    Token fn;
    Token t_aggregate = null;
    String aggregateName = null;
} {
    <lpar> expression=NumericSum(selector) <rpar> {
        return expression;
    } |
    value=ParseNumber() {
        /* Make an Expression from the value */
        return selector.getLogicSelector().getResourceManager().getCriteriaBuilder().literal(value);
    } | expression=FieldValExpr(selector) {
        return expression;
    }
}

Expression<Number> FieldValExpr(ArithmeticSelector selector): {
    Number value;
    Token fn;
    Token t_aggregate = null;
    String aggregateName;
} {
    ((t_aggregate=<aggregate> <lpar> fn=<fieldname> <rpar>) | (fn=<fieldname>)) {
       if(t_aggregate != null) {
           aggregateName = t_aggregate.image;
           return selector.getLogicSelector().getAggregateOf(aggregateName, selector.getLogicSelector().getReferencedFieldOfType(fn.image,  Number.class));
       }else {
           return selector.getLogicSelector().getReferencedFieldOfType(fn.image,  Number.class);
       }
}
}

Number ParseNumber(): {
    Token t;
}{
    /* INT */
    t = <integer>
    {
        return Integer.valueOf(t.image);
    } |
    t = <floatingpoint>
    {
        return Double.valueOf(t.image);
    } |
    <numberize> <lpar> t=<bool> <rpar>
    {
    boolean value = Boolean.parseBoolean(t.image);
    return value ? 1 : 0;
}

}

Object ParseValue(): {
    Token t;
    StringBuilder stringBuilder = new StringBuilder();
} {
    /* STRING */
    <quote> (getChar(stringBuilder))* <endquote>
    {
        return stringBuilder.toString();
    } |
    /* INT */
    t = <integer>
    {
        return Integer.valueOf(t.image);
    } |
    t = <floatingpoint>
    {
        return Float.valueOf(t.image);
    } |
    t = <bool>
    {
        return Boolean.valueOf(t.image);
    } |
    t = <datetime>
    {
        return Utils.parseDateTime(t.image);
    }
}

void getChar(StringBuilder builder): {
    Token t;
} {
    t = <CHAR>
    {
        builder.append(t.image.charAt(0));
    } |
    t = <cntrl_esc>
    {
        Utils.convertEscapedCharacter(builder, t.image.charAt(1));
    }
}

void Order(Order order): {
    Token fn;
    Token direction;
} {
    (<t_order> (fn=<fieldname> (direction=<ascending> | direction=<descending>) {Utils.processOrder(fn.image, direction.image, order);})+)?
}

Expression ResultField(ResultField resultField): {
    Token fn;
    Token t_aggregate;
} {
    t_aggregate=<aggregate> <lpar> fn=<fieldname> <rpar> {
        return resultField.handleResultField(fn.image, t_aggregate.image);
    } |
    fn=<fieldname> {
        return resultField.handleResultField(fn.image, null);
    }
}

void Result(Result result, ResultField resultField): {
   Expression expression;
}{
    <t_result> (expression=ResultField(resultField) {result.addResultField(expression);})+
}

void Group(Group group): {
    Token t;
} {
    (<t_group> (t=<fieldname> {group.addField(t.image);})+ With(group.getWithClauseSelector()))?
}

void With(WithClauseSelector selector): {
    Predicate predicate;
} {
    (<with> predicate=SelectorLogicOr(selector) {selector.setWithPredicate(predicate);})?
}


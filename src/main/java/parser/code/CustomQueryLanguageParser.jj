options {
  OTHER_AMBIGUITY_CHECK = 1;
  STATIC = true;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = false;
  IGNORE_CASE = false;
  USER_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = false;
  BUILD_PARSER = true;
  BUILD_TOKEN_MANAGER = true;
  SANITY_CHECK = true;
}

PARSER_BEGIN(CQLParser)
package parser.generated;

import java.util.*;
import parser.helper.*;
import parser.querybuilder.*;
import javax.persistence.criteria.Predicate;

/**
 * Simple brace matcher.
 */
public class CQLParser {

  /** Main entry point.
  public static void main(String args[]) throws ParseException {
    CQLParser parser = new CQLParser(System.in);

    Expr expr = parser.FilterLogicOr();

    System.out.println();
  }*/


}

PARSER_END(CQLParser)

TOKEN : {
    /* Blocks */
    <t_order: "order"> |
    <t_filter: "filter"> |
    <group: "groups"> |
    /* Logic */
    <and: "and"> |
    <or: "or"> |
    <lpar: "("> |
    <rpar: ")"> |
    /* Ordering */
    <ascending: "ascending"> |
    <descending: "descending"> |
    /* Groups */
    <with: "with"> |
    /* comparison operators */
    <equal: "="> |
    <greater: ">"> |
    <greater_eq: ">="> |
    <smaller_eq: "<="> |
    <smaller: "<"> |
    <between: "between"> /* this is not a binary operator */ |
    <like: "like"> |
    <startwith: "startswith"> |
    <endswith: "endswith"> |
    <contain: "contains"> |
    <in: "in"> /* requires list specification TODO: implement lists */ |
    <hasflag:"hasflag"> /* requires flag implementation TODO: implement flags */ |
    /* data-types */
    <quote: "\""> : STRING_STATE |
    <integer: ("-")?["1"-"9"](["0"-"9"])*> |
    <floatingpoint: ("-")?((["1"-"9"](["0"-"9"])*)|("0"))"."["0"-"9"](["0"-"9"])*(("e"("-")?["1"-"9"](["0"-"9"])*)?)?> |
    <bool: "true" | "false"> |
    <datetime: (["0"-"9"]){2}"."(["0"-"9"]){2}"."(["0"-"9"]){4}(" "((["0"-"9"]){2}":"(["0"-"9"]){2}))?> /* dd.mm.yyyy HH:MM */ |
    /* fieldnames */
    <fieldname: ["a"-"z","A"-"Z"](["0"-"9","a"-"z","A"-"Z"])+>
}

<STRING_STATE> TOKEN : {
    <endquote: <quote>> : DEFAULT
   |<CHAR: ~["\"", "\\"]>
}

<STRING_STATE> MORE : {
    "\\" : ESC_STATE
}

<ESC_STATE> TOKEN : {
    <cntrl_esc: ["\"", "\\", "/", "b", "f", "n", "r", "t"]> : STRING_STATE
}

SKIP : {
    " " | "\t" | "\n"
}



Predicate Filter(Filter filter) : {
    Predicate predicate;
}{
    <t_filter> predicate=FilterLogicOr(filter) {return predicate;}
}

Predicate FilterLogicOr(Filter filter):
{
    Predicate predicate1;
    Predicate predicate2;
    List predicates = new LinkedList();
}
{
    predicate1=FilterLogicAnd(filter) (<or> predicate2=FilterLogicAnd(filter) { predicates.add(predicate2); } )*
    {
        predicates.add(predicate1);
        return filter.handlePredicateList(predicates, LogicOperator.Or);
    }
}

Predicate FilterLogicAnd(Filter filter):
{
    Predicate predicate1;
    Predicate predicate2;
    List predicates = new LinkedList();
}
{
    predicate1=FilterLogicBaseCase(filter) (<and> predicate2=FilterLogicBaseCase(filter) { predicates.add(predicate2); })*
    {
        predicates.add(predicate1);
        return filter.handlePredicateList(predicates, LogicOperator.And);
    }
}

Predicate FilterLogicBaseCase(Filter filter): {
    Token t;
    Predicate predicate;

}
{
    <lpar> predicate=FilterLogicOr(filter) <rpar>
    {
        return predicate;
    } |
    predicate=ComparisonExpression(filter)
    {
       return predicate;
    }
}

Predicate ComparisonExpression(Filter filter): {
    Token fn;
    Token cop;
    Object value;
    Object value2;
}
{
    fn=<fieldname> ((cop=<equal> | cop=<greater> | cop=<smaller> | cop=<greater_eq> | cop=<smaller_eq> | cop=<like> | cop=<startwith> | cop=<endswith> | cop=<contain> ) value=ParseValue()
    {
        return Utils.processBinaryComparison(fn.image, cop.image, value, filter);
    } | ( cop=<between> value=ParseValue() <and> value2=ParseValue()
    {
    return Utils.processTernaryComparison(fn.image, cop.image, value, value2, filter);
}))
}

Object ParseValue(): {
    Token t;
    StringBuilder stringBuilder = new StringBuilder();
} {
    /* STRING */
    <quote> (getChar(stringBuilder))* <endquote>
    {
        return stringBuilder.toString();
    } |
    /* INT */
    t = <integer>
    {
        return Integer.valueOf(t.image);
    } |
    t = <floatingpoint>
    {
        return Float.valueOf(t.image);
    } |
    t = <bool>
    {
        return Boolean.valueOf(t.image);
    } |
    t = <datetime>
    {
        return Utils.parseDateTime(t.image);
    }
}

void getChar(StringBuilder builder): {
    Token t;
} {
    t = <CHAR>
    {
        builder.append(t.image.charAt(0));
    } |
    t = <cntrl_esc>
    {
        Utils.convertEscapedCharacter(builder, t.image.charAt(1));
    }
}

void Order(Order order): {
    Token fn;
    Token direction;
} {
    <t_order> (fn=<fieldname> (direction=<ascending> | direction=<descending>) {Utils.processOrder(fn.image, direction.image, order);})+
}
